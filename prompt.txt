// lib/features/product/data/datasources/product_api_service.dart

import 'package:dio/dio.dart';
import 'package:gmedia_project/core/constant/api_urls.dart';
import 'package:gmedia_project/core/network/dio_client.dart';
import 'package:gmedia_project/core/resources/data_state.dart';
import 'package:gmedia_project/core/services/services_locator.dart';
import 'package:gmedia_project/features/product/data/model/product_model_request.dart';
import 'package:gmedia_project/features/product/data/model/product_model_response.dart';

abstract class ProductApiService {
  Future<DataState<List<ProductResponseModel>>> getProducts();
  Future<DataState<ProductResponseModel>> getProductById(String id);
  Future<DataState<ProductResponseModel>> createProduct(ProductRequestModel product);
  Future<DataState<ProductResponseModel>> updateProduct(String id, ProductRequestModel product);
  Future<DataState<void>> deleteProduct(String id);
}

class ProductApiServiceImpl implements ProductApiService {
  final DioClient _dioClient = sl<DioClient>();

  @override
  Future<DataState<List<ProductResponseModel>>> getProducts() async {
    try {
      final response = await _dioClient.get(ApiUrls.product);

      if (response.statusCode == 200) {

        final List<dynamic> productListJson = response.data['data'];

        final List<ProductResponseModel> products = productListJson
            .map((productJson) => ProductResponseModel.fromJson(productJson as Map<String, dynamic>))
            .toList();
      
        return DataSuccess(data: products);
      } else {
        return DataFailed(
          DioException(
            requestOptions: response.requestOptions,
            response: response,
            error: 'Failed to load products',
          ),
        );
      }
    } on DioException catch (e) {
      return DataFailed(e);
    }
  }

  @override
  Future<DataState<ProductResponseModel>> getProductById(String id) async {
    try {
      final response = await _dioClient.get('${ApiUrls.product}/$id');

      if (response.statusCode == 200) {
        final product = ProductResponseModel.fromJson(response.data['data']);
        return DataSuccess(data: product);
      } else {
        return DataFailed(
          DioException(
            requestOptions: response.requestOptions,
            response: response,
            error: 'Failed to load product',
          ),
        );
      }
    } on DioException catch (e) {
      return DataFailed(e);
    }
  }

  @override
  Future<DataState<ProductResponseModel>> createProduct(ProductRequestModel product) async {
    try {
      final formData = await product.toFormData();
      final response = await _dioClient.post(
        ApiUrls.product,
        data: formData,
      );
      if (response.statusCode == 201 || response.statusCode == 200) {
        final newProduct = ProductResponseModel.fromJson(response.data['data']);
        return DataSuccess(data: newProduct);
      } else {
        return DataFailed(
          DioException(
            requestOptions: response.requestOptions,
            response: response,
            error: 'Failed to create product',
          ),
        );
      }
    } on DioException catch (e) {
      return DataFailed(e);
    }
  }

  @override
  Future<DataState<ProductResponseModel>> updateProduct(String id, ProductRequestModel product) async {
    try {
      final formData = await product.toFormData();
      
      final response = await _dioClient.post(
        '${ApiUrls.productById}/$id', 
        data: formData,
      );

      if (response.statusCode == 200) {
        final updatedProduct = ProductResponseModel.fromJson(response.data['data']);
        return DataSuccess(data: updatedProduct);
      } else {
        return DataFailed(
          DioException(
            requestOptions: response.requestOptions,
            response: response,
            error: 'Failed to update product',
          ),
        );
      }
    } on DioException catch (e) {
      return DataFailed(e);
    }
  }

  @override
  Future<DataState<void>> deleteProduct(String id) async {
    try {
      final response = await _dioClient.delete('${ApiUrls.product}/$id');

      if (response.statusCode == 200 || response.statusCode == 204) {
        return const DataSuccess(data: null);
      } else {
        return DataFailed(
          DioException(
            requestOptions: response.requestOptions,
            response: response,
            error: 'Failed to delete product',
          ),
        );
      }
    } on DioException catch (e) {
      return DataFailed(e);
    }
  }
}

// lib/features/product/domain/entities/product_request_entity.dart

import 'dart:io';

class ProductRequestEntity {
  final String categoryId;
  final String name;
  final num price;
  final File picture;

  ProductRequestEntity({
    required this.categoryId,
    required this.name,
    required this.price,
    required this.picture,
  });
}

// lib/features/product/domain/entity/product_entity_response.dart

class ProductEntityResponse {
  final String id;
  final String categoryId;
  final String name;
  final int price;
  final String pictureUrl;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  final DateTime? deletedAt;

  ProductEntityResponse({
    required this.id,
    required this.categoryId,
    required this.name,
    required this.price,
    required this.pictureUrl,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });
}



// lib/features/product/data/models/product_request_model.dart

import 'package:dio/dio.dart';
import 'package:gmedia_project/features/product/domain/entity/product_entity_request.dart';

class ProductRequestModel extends ProductRequestEntity {
  ProductRequestModel({
    required super.categoryId,
    required super.name,
    required super.price,
    required super.picture,
  });

  Future<FormData> toFormData() async {
    return FormData.fromMap({
      'category_id': categoryId,
      'name': name,
      'price': price,
      'picture': await MultipartFile.fromFile(
        picture.path,
        filename: picture.path.split('/').last, 
      ),
    });
  }
}

// lib/features/product/data/models/product_model.dart

import 'package:gmedia_project/features/product/domain/entity/product_entity_response.dart';

class ProductResponseModel extends ProductEntityResponse {
  ProductResponseModel({
    required super.id,
    required super.categoryId,
    required super.name,
    required super.price,
    required super.pictureUrl,
    super.createdAt,
    super.updatedAt,
    super.deletedAt,
  });

  factory ProductResponseModel.fromJson(Map<String, dynamic> json) {
    return ProductResponseModel(
      id: json['id'],
      categoryId: json['category_id'],
      name: json['name'],
      price: json['price'],
      pictureUrl: json['picture_url'],
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'])
          : null,
      updatedAt: json['updated_at'] != null
          ? DateTime.parse(json['updated_at'])
          : null,
      deletedAt: json['deleted_at'] != null
          ? DateTime.parse(json['deleted_at'])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'category_id': categoryId,
      'name': name,
      'price': price,
      'picture_url': pictureUrl,
      'created_at': createdAt?.toIso8601String(),
      'updated_at': updatedAt?.toIso8601String(),
      'deleted_at': deletedAt?.toIso8601String(),
    };
  }

  ProductEntityResponse toEntity() {
    return ProductEntityResponse(
      id: id,
      categoryId: categoryId,
      name: name,
      price: price,
      pictureUrl: pictureUrl,
      createdAt: createdAt,
      updatedAt: updatedAt,
      deletedAt: deletedAt,
    );
  }
}

import 'package:gmedia_project/core/resources/data_state.dart';
import 'package:gmedia_project/features/product/domain/entity/product_entity_request.dart';
import 'package:gmedia_project/features/product/domain/entity/product_entity_response.dart';
import 'package:gmedia_project/features/product/domain/usecase/get_list_product_usecase.dart';

abstract class ProductRepository {
  Future<DataState<List<ProductEntityResponse>>> getProducts(GetListProductParams? params);
  Future<DataState<ProductEntityResponse>> getProductById(String id);
  Future<DataState<ProductEntityResponse>> createProduct(ProductRequestEntity request);
  Future<DataState<ProductEntityResponse>> updateProduct(String id, ProductRequestEntity request);
  Future<DataState<void>> deleteProduct(String id);
}



sekarang buat repository impl nya
// lib/features/product/data/repository_impl/product_repository_impl.dart

import 'package:gmedia_project/core/resources/data_state.dart';
import 'package:gmedia_project/features/product/domain/entity/product_entity_request.dart';
import 'package:gmedia_project/features/product/domain/entity/product_entity_response.dart';
import 'package:gmedia_project/features/product/domain/repository/product_repository.dart';
import 'package:gmedia_project/features/product/domain/usecase/get_list_product_usecase.dart';

class ProductRepositoryImpl implements ProductRepository {
  @override
  Future<DataState<ProductEntityResponse>> createProduct(ProductRequestEntity request) {
    // TODO: implement createProduct
    throw UnimplementedError();
  }

  @override
  Future<DataState<void>> deleteProduct(String id) {
    // TODO: implement deleteProduct
    throw UnimplementedError();
  }

  @override
  Future<DataState<ProductEntityResponse>> getProductById(String id) {
    // TODO: implement getProductById
    throw UnimplementedError();
  }

  @override
  Future<DataState<List<ProductEntityResponse>>> getProducts(GetListProductParams? params) {
    // TODO: implement getProducts
    throw UnimplementedError();
  }

  @override
  Future<DataState<ProductEntityResponse>> updateProduct(String id, ProductRequestEntity request) {
    // TODO: implement updateProduct
    throw UnimplementedError();
  }
}

